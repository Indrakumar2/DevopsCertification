Linux Refresher:

Linux was developed by LinusTorvads in 1991

Components:

Bootloader---> A software to manage the booting process of a computer,responsible for loading the operating system in the memory.

Kernel----> it manages the CPU,Memory and Peripheral Devices,It acts as a core interface to communicate b/w the two managing resources.
            effeciently

init System----->exceuted by the linux kernel after the early stages  of bootup completion by the boot loader, it is a subsystem that bootstraps the user
                 space and is charged with controlling the daemons.

Daemons----->These are the background services that either start up during the boot or after logging in to the desktop.
             These Daemons are responsible for managing many parts of the system like, log information, watching for the devices that are inserted or removed & managing the user login.


Graphical Server----->It is refered to as X-server. It render images and shapes on a computet monitor.

Desktop Environment----->The component with which the users interact the most and includes built-in applications.

Applications-----> Desktop environment do not offer the full array of apps, but these applications can installed as per the requirements


Linux Distributions:

it is also refer to as Distros is the term to describe the linux versions.

Ubuntu,Debian, Centos, Fedora, linux mint, opensuse, Archlinux, Elementry os.  


Linux in Devops:
The goal of the Devops is to deliver the software at the faster pace means, building on existing insfrasturcture


Faster Development-------Open Source-------Flexible---------------Scalable

Linux Administration is about managing system operations such as,
----->File Backups and Restorations
------>Disaster Recovery
------>New System Builds
------>Hardware, Software & User Maintainance
------>File System housekeeping
------>Application Installation and Configuartion






Devops overview
Devops is the agile relationship b/w Development and IT operations
Developement+Operations
managing entire Application


                  DEV                 +                 OPS
plan--->Create---->verify---->package---->Release--->configure---->Monitor


Traditional Software Development Approach:

---->Waterfall Model
-----> Agile Model


Waterfall Model
---->It uses a linear and Sequential  Approach for software Development

Stages:

---->Requirement Analysis

                     ------->System Design 
         
                                       ------>Implementation 

                                                        ------->Testing 

                                                                     -------->Deployment
 
                                                                                      ------->Maintainance
Pros:                               Cons:
Easy to use                         Risky & Uncertain
cost Effective                      Not suitable for Complex Projects
Time saving                         Final Product Available only at the end
Easy testing                        not suitable for projects with the changing Requirements
suitable for small Projects         Difficult to make changes in the testing phase
Managerial Control




Agile model:

it is a combination of iterative and incremental process models that focuses process adaptibility and customer satisfaction
by rapid delivery of the working software product.

It breaks the product into small incremental builds,these builds are provided in iterations

working:
----->Product Backlog : it is pretty much all the things that the business wants to get from the software development team
                        Product backlog may have an infinite number of items, but need to decide what we are going to work on in a given period of software development.

------>Sprint Backlog : The above phenomenon is known as Sprint Planning, Leaders from the Software Development team would look at the backlog and Decide what will be
                         implemented in a given sprint.

A Passing Sprint means that the items from the product backlog that's been introduced in the sprint have been created, shipped and Deployed

A failing Sprint is one were not all works been done

irrespective of the sprints pass or fail most companies have reterespective on all sprints were things that worked and things that didn't work are dicussed  along with figuring out
to improve the process

the Scrum team will do plan, Develop, test during the sprint that usually b/w 4-weeks, the scrum team will meet daily, disscusing in the progress of the project


Pros:                                                     Cons
Dynamic Response to requirements                          poor Documentation
Cost Effective                                            Difficult to estimate time and effort for complex projects
Superior Quality Product                                  Risky due to the ever evolving characteristics
Direct Communication b/w the stake holders                Difficult to predict the expected results when requirements are unclear
Best suited for large and long term projects
Minimum Resource Requirement




Relationship b/w Agile and DevOps

using automation tools
Improve collaboration b/w the teams
Create an automated deployment process that moves code from the repository 



DASA DevOPS Principle:

The DevOps Agile Skills Association Defines Certain principle for Devops

Customer-Centric Action

Create with the end in mind

End to End Responsibility

Cross-Functional Autonomous teams

Continous Improvement

Automate Everything you can



Lifecycle

---> Continous developement[Manifests planning and coding, The scope of the project is determined during the planning and developers bulid the code]
               


              ---> Continous Testing[in this phase teh code has been rigoursly tested for bugs,Here entire testing is automated, Jenkins assist in conducting automation of test procedure so that it saves a lot of time]
                            


                              -----> Continous integration[it's the essential phase of DevOps, which deals with the software development. Frequent changes are made to the code
                                                                Building code not only involves complilation but it also includes, UNIT TESTING, INTEGARTION TESTING,CODE REVIEW, CODE PACKAGING]
 


                                          
                                         ------>Continous Deployment[the new code is deployed frequently and  the configuration management tools are required to achive
                                                                            Contiainerization also plays a pivtol role in the deployment process
                                                                            These tools helps to maintain consistency throughout ---->development-----staging----testing----production]




                                                            ------> Continous Monitoring[it includes all operational aspects,it maintains the security and availabilty of the service]




Tool Categories:

SCM, Testing, Software Build,Integartion, CMT and Deployment, Monitoring, Continerization


SCM:
Tracking source Code Changes and history of changes in the code base, and helps resolve conflicts when merging updates from multiple contributors
Git,Github

Software Build:
Maven

Testing:

Selinium

Integration

Jenkins

CMT and Deployment:
Continous Dep & Operations

Codeship, AWSCode Deploy, Terraform , Ansible ,Chef, Puppet, saltstack

Monitoring:

Nagios and Splunk,Amazon cloudwatch, grafana, datadog

Containerization:
It is defined as the form of operating system virtualization through which applications are run in isolated user spaces called containers, all using the same shared OS
Docker and Kubernetes

Benifits of Devops:

Assured Rapid Deployment
Balanced Working Environment
Drastic Improvement over quality
Repetative task is Automated
Proactive growth of business
Continous Delivery
Minimal Cost of production
Higher Productivity



DevSecOps:

for security concerns instead of retrofitting the security into the build,it tries to integrate the management of securtiy throughout the development process.

DevSecOps Benefits:
Rapid Cost-Effective Software Delivery
Repeatable and Adaptive Process
improved,proactive Security
Accelerated security vulnerbility patching
automation compatible with modern development




DevOps On Cloud:
Features of cloud ---> 
 
scalability
Elasticity
Availability
Reliability
Manageability
Interoperability
Accessibility
Portability
Perfromance
Optimization


the Cloud service can be categorized in three ways:

Infrastructure as Service (IaaS)--->It is an Instant computing infrastructure service that provides virtualized computing resources over internet.

Platform as Service (PaaS)----->It is a method were users are allowed to build, test, debug, deploy, host, and update their applications in the same environment.

Software as Service (SaaS)---->It is a method of delivering the applications as a service,so that users are free from complex software and hardware management.



Version Control System:

If a project consist of Technical concepts, Collabration b/w different team members, Frequent changes.

A Version control system allows users to keep track of the changes in the software developement projects and enables them to collaborate on thode projecys

Purpose:

Records changes to set of files

Track every individual change by each contributor

Supports a developers preference and is felxible to use

Faclitates a smooth and continous flow of changes to the code


VCS Stremline in a project:

Allows easy issue tracking

provides a complete long term change history of every file with large file storage

Facilitates easy branching and merging 

Helps in tracking each change made to the software

Tracks the status of each step in the pipeline

Allows Developers to tell each other about different changes pushed to a github repository

Gives real time insights into the codebase 

Offers unlimited free private and Public repositories


Benifits:

Collabrate

Storing versions 

Restoring previous versions 

Understand what happend 

Back up


Types of VCS

Local Version control System: It maintains the track on files within the local system

                               It is very common and simple approch
                                
                               This method very error prone, which means the chances of accidentally writting to the wrong file is higher



Centralised Version Control System: It uses Centralized server to store the files and all the changes in the files are also tracked under the centalized server

                                    This centralized server also includes all the information of version files and list of clients that checkout files from that central place

Distributed Version Control System: It moves from the client-server approach of the centralized version control system to a peer to peer approach
                                     
                                    The clients can completely clone the repository including its full history

                                    If any server dies any of the client repository can be copied onto the server immediately 



Tools: GitHub, Gitlab, Apache Subversion and Mercurial


Overview of git:

It is type of DVCS

Git allows multiple developers to work together and supports the non-linear developement because of the parallel branches

Git is a software that runs locally the files and their history are stored in the computer

Online hosts are available to store the copy of the files and their revision history

Purpose:

It tracks changes in the source code

User distributed version control tool for source code management

Allows multiple developers to work together

Supports non-linear developement because of its several parallel branches

Benefits:

Has flexible environment 

Facilitates branching and merging 

keeps the files in the secure server

creates and manage remote repositories

Git Repository:

A git repository contains all of the projects files and each file revision history, this can be used for discussion and manage the projects work with in the repository


Charcteristics :

The users can have access to the files in the local repository, Whether it's a single or multiple files 

The user can view the public repository by usingt the url of the particular repository

Each repo belongs to a team or a user

    if in the case of User account the user owns the repository
    if in the case of team the team owns it

The repository owner is the only person who can delete the repository

If it is belongs to a team only admin can delete the repository

A code project consists of multiple repositories across multiple accounts, but also can be a single repository from a single account
 
Each repository has 2GB size limit , but it is recommended  to keep the repository to no longer more than 1GB




Life cycle of git:

Repository ------> clone Operation ----->working copy-----> Modify the working copy(Upadate the other developer files in the working copy[status differnce operation])------>review the changes (Commit and push changes)
------>Commit changes [push operation][amend and push operation]------>Fix Mistakes [Push the changes]


Git stages 


    Committed                      modified				staged   [Each state relates to a specific git section]


    Working Directory              staging area                         git directory



Working Directory: it is local physical directory were changes can be done to the files

Staging area:  it is the place were the git keeps a reference of all modifications to be sent to the next commit

Git directory: it is the repository that stores all files in a compressed form
  

Untracked files resides only in the workiing directory ie, they don't reflect in the git directory

Modified files resides in both working directory and git directory they have diffrent versions ie, the working directory files were changed, but those changes weren't sent to the staging area

Staged files resides in the both working directory and git directory if they are existing files being changed or they don't reside in the git directory, ifthey are new file is being added to the respository for the first time

Commited files resides on the both working directory and gir directory with the exact same version.








CI/CD With Jenkins:

Prerequisites-----> Automated bulid tests, Package and deploy operations
                    Quick Pipeline Execution 
                    Quick failure recovery
                    Zero-Downtime deployment
                    Trunk-based Developement 


Jenkins:

Written entirely in java

Benefits: 
Its free

It is  highly portable application

It can be easily installed and configured as per the required needs

It has a vry rich plugin library and global community support

It can be integrated with limitless other applications and tools.


Process of CI in Jenkins:

All the commits are built-------Jenkins CI will check for the builds-------Once the build id fine, the executable code is ready for deployment--------Otherwise the team
of developers who will commit changess at regular intervals are notified



Job Types in jenkins:

Freestyle Project
Maven Project
External Job
Multi-Configuration project
Pipeline
Folder
Github organization
Multibranch Pipeline

Poll SCM:

It periodically builds SCM, It involves checking the versions at regular intervals for any changes that have been commited 


Webhooks:

It helps to transfer realtime data from one application to another and provide the application a way of consuming new event data from an endpoint.

Bulid Periodically:

It builds the project periodically even if nothing has changed. It might have tests that shpuld be run periodically or a DB Clean up jenkins job or any other jenkins job.


Scheduling Jenkins Job:

Scheduled builds simply trigger your bulid job at regular intervals

This statergy can be used for regular night bulids

They can be done with something as simple as a unix cronjob

continous integration requires faster feedback than scheduled bulids

scheduled builds can be used for long running build jobs, where quick feedback is less critical


Syntax:

It uses cron style syntax for scheduling the jobs

              *                  *                   *                              *                       *      
 
         minutes(0-59)  ----  hour(0-23) ----- Day of the Month(1-31)------- month(b/w 1-12) ------ day of the week (0-7 ,where 0&7 are sunday)  



 
notations: 
             '*' --------> represents all possible values for a field  ------- means  once a minute
   
              'M-N' -------> Defines the ranges --------- 1-5 in the DOW field would mean monday to friday

               '/' -------> Defines skips through the ranges ------- */15 in the MINUTE field would mean every 15 minutes

               Comma separated List -------> indicates a list of  valid values ------- 15,45 in the minute field would means at 15 and 45 minutes past evry hour

               Shorthand values                                                  -------- @yearly, @weekly, @Daily, @annualy, @daily, @midnight, and @hourly



Bulid Tools:

Apache ANT & MAVEN

Benefits: 

Easy Configuration 

Easy Support 

Easy Integartion


Maven:

Maven is the bulid tool for managing software dependencies and life cycles.It automatically pulls code from a repository, compiles and packages it, and prepares it for 
the next stage of developement

Tasks:
It can easily create a project 

It is consistent across all the projects

It can connect a project to a source control system

It has the ability to handle muiltiple projects simultaneously

It follows a Standard stratergy


Pros:

It can automatically add all of the project's dependencies by reading a pom file

It can convert a project to war file format easily

It makes it simple to start a project in a variety of contexts and it eliminates the need to manage the dependencies, builds and processing

Cons:

Maven Must be installed on the system before it can be used 

Maven will not be able to add an existing dependency if the maven code for it is not available


Continous integration with maven:
Tutorial need to be done




Automation Testing Framework:

  Overview:

         What AT means?

           Automation testiing is  an application software testing process using software tools to control the execution of tests
           The actual test results are compared with the expected test results



Manual Testing:

It is a form of software testing in which test cases are run by a human rather than using an automated tool.

The Mannual software testing can be summed as:

Time-consuming to test all work flows, fields and bad cases

Hectic for multilingual sites 

Tedious and, as a result, prone to errors


Automation testing can be summed as :

Accelerates the execution of tests 

Helps to increase the test coverage 

Eliminates the need for human interference

Test cases:
 What test cases need to be automated?

The criteria for the test cases, we should keep in our mind,

Test cases are High risk and business critical

Test cases are Executed Repeatedly

They are very monotonous or exhausting to perform manually and those which takes laborious time

Important to note that Automation testing is not appropriate to use in the test cases:

That are ewly designed and have never been manually executed at least once
Test cases whose requirements change frequently
Test cases whose executedin ad-hoc situations


Automation testing process and its popular tools:

Determine the scope automation

Test automation tool selection

Test planning, design & developement

Test Execution

Test automation management



Determine the scope of automation:
The specific area of your application software that will be automated

Guidlines to assess scope:

Empirical(based on experiments and practical experience, not on ideas.)features that are essential for application software
Larger data involvement scenarios of the application software
Identical functionalities shared by the application software products          
The technical feasibility of the appication software

Test Automation Tool selection:
It maybe necessary to evaluate the project specifications attentively by using the scope of automation, the right selection of automation tools, testing processes and teams 
is important for successful automation


Test Planning, Design and Developement:
Once setup an automation strategic framework using this stage and incorporate relevant information such as the selection of automation tools as per the requirement such as,

Selection of automation tools as per requirements 
Framework designs and their characteristics
The automation components that are in & out of scope
The preparation of an automated testbed
Schedule and Timeline of scripting and execution


Test Execution:

The automation scripts require input test data, therefore it generates extensive test reports after execution
Automation scripts are executed at this juncture.Before they may be set to execute, the scripts require input test data,Therefore it generates extensive test reports after 
execution
the automation tool can be used directly or the test management tool can activate the automation tool


Test Automation Management:

It is an approach is a phase of automation testing that is used to see if the new feature added to the software are working properly.
When new automation scripts are added they must be renewed and maintained to  improve the effectiveness of the automation scripts with each release cycle


Tools in Automation:

'Ranorex' studio is a one-stop solution for automation fuctional user interface tests, regression tests, driven tests, and more
'Testim' is the qucikest way to create durable end-to-end tests, whether theyare codeless, programmed or both .It not only allows to write incredibly stable codeless tests,
That the leverage our AI, but it also gives the option to export test as code
'Lamdatest' is used to perform automated  cross-browser testing.They provide a selnium grid that is ultra fast,Scalable and secure allowing customers to conduct tests on
over 2000 browsers and operating systems
'Selelinum', is a software testing tool that's used to perform regression testing.Its a open source regression testing tool that includes playback recording capabilities


Selenium:

It is an umbrella project that includes a set of tools and libraries that enable and support web browser automation


Features of selenium :

It's a opensource, portable framework used to automate the web applications testing
It's highly flexible when it's come to testing functional & regression testcases
It also Supports cross browsing where the test cases run across various platforms simultaneously
Helps on creating robust, browserbased regression automation suites and perform automation test execution

Selenium Webdriver Architecture:
It is the most Significant component of the selenium tool suite

The test script can be written in any if the supported programming languages and run directly in most contempary web browsers using webdriver, includes such as C#, JAVA, Perl, PHP,Phython, Ruby and many others.
  The selenium webdriver is currnetly in the rise with Java and C#

The architecture layout of selenium web driver which is categorized into four main components:
Selenium language bindings also Selenium client libraries-------json wire protocol------Browser drivers------real browsers

The HTTP server, undertake the responsibilty to bridge communication b/w browser driver and real browser.



Selenium Language Bindings: It has language binaries or selenium client libraries to support multiple languages. For instance, when we want to access the browser driver 
in java by using the java bindings

JSON Wire Protocol: JSON is a web based data exchange standard. This manages data structures,such as objects and arrays. In a Nutshell Writting and reading data from JSON is Simple.
The JSON Wire protocol is data exchange that commuicates b/w a server and a client

Browser Drivers: Selenium uses exclusive drivers for each browser in establishing a safe connection with the browser without comprising the internal logic of the browser functionalities.

Real Browser: Selenium Webdriver is compatible with the major browser to arrange podium to the web application for testing such as internet explorer, mozilla firefox,Google chrome, safari etc.,




Configuration Management:

It is a system engineering method that ensures a product's characteristics remain consistent during its life cycle

It provides a configuration model of the services, assets,and infrastructure by recording the relationship b/w service assets & configuration items, it also ensures that the release in a controlled environments and operational use are
completed on the basis of former approvals.

It may cover Non-IT assets and work products used to develop services and configuartion items are required to support services that aren't listed as assets

Any change in configuartion can dramatically impact : the performance ,the security, the functionality of the code in the underlying of the IT assets

Any component that requires management to deliver IT service is considered part of scope of the configuration management, this process maintains information about any CI
 required to deliver an IT Service, including its relationship and this information is managed throughout lifecycle of the CI

So, the objective of configuration management is to define and control the components of the IT service and its infrastructure, and to maintain accurate configuration information

The Configuration Management application : identifies, defines and tracks an organization's configuration items (CI) by creating and managing records for those items

other service management applications can then access these records  from central repository

Eg:If we are creating an incident, you can take all the data related to hardware components from configuration management. Next, we can use the same information to create
a new incident. Access to configuartion management significantly reduces the time spent to reslove the incident and alerts us to other future risks triggered by other 
component relationships and dependencies defined in the database

Roles of Configuration Management Tools:

Configuration management tools enabled changes and deployments to be faster, repeatable, scalable, predictable, and able to maintain the desired state, which brings controlled
assests into an expected states.

Advantages:

It helps to increase the efficency with a well defined configuration process that improves visibility and provides control with the help of tracking

It helps in cost optimization by having a detailed knowledge of all the IT Elements of the configuration, which helps to avoid unnecessary duplication 

Track requirements from specification to testing

Identifies and control the software versions

It enhances system and process reliability and correcting the incorrect configurations before a detrimental effect on results

It manages the information about the configuration items

It provides faster restoration of your service if process failure occurs

Facilitates the conduct of functional configuration audits 





Popular Configuration management Tools:

Saltstack, Ansible, Chef, Puppet

Saltstack----->It is a python based open-souce configuartion management tool used to remotely manage configuration items

Ansible------->It is also python based CM tool, also considered as agentless CM tool

Chef-------->It is a ruby based CM Tool having integartion with most of the cloud-based platforms

Puppet------> Ruby DSL-based CM tool used for managing software,systems, and network configuration items


Ansible Overview:
 It's an IT automation engine that automates the cloud provisioning, configuration management , application deployment, Intra service orchestration and a variety of IT tasks

Ansible was built from the ground up for multitier deployments, and instead of controlling one system at a time it models the IT Architecture by defining how all of the systems interact

Ansible uses playbook to describe automation jobs which are written in YAML-it is a human readable data serialization language mainly used for configuration files

Ansible was designed for multi-tier deployment

Ansible models the IT infrastructure by interrelating all the systems

It was constructed for multi-level use from the ground up


Components of Ansible: 

Modules, Module Utilities, Plugins, Inventory, playbooks, the Ansible search path

Modules: Ansible connects nodes and sends scripts known as Ansible Modules
         User can write their own modules 
         Most module accept parameters that define the systems desired state.
Ansible runs these modules by default over ssh and removes them after when they finished
The module library can be stored on any computer and no servers, daemons or databases needed.

Module Utilities: Ansible stores functions as modules utilites when several modules use the same code, to reduce duplication and maintainance. However only python or powershell can be 
used to build module utilities


Plugins: Ansible's core fuctionality is augumented by plugins. Plugins execute on the control mode within the /user/bin/ansible method, While modules execute on the target system in separate processes usually on remote system
























